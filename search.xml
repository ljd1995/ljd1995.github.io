<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web后端开发知识点</title>
      <link href="/post/c3df8a2e/"/>
      <url>/post/c3df8a2e/</url>
      
        <content type="html"><![CDATA[<h2 id="做Web后端开发需要学习什么"><a href="#做Web后端开发需要学习什么" class="headerlink" title="做Web后端开发需要学习什么"></a>做Web后端开发需要学习什么</h2><ol><li>学习一门面向对象的编程语言（java、python、go、nodejs、c#、php）</li><li>学习一个web框架（python：Flask/Django/Sanic go: Gin/Beego/GoFrame nodejs: egg.js koa express php: Larvel/ThinkPhp java: Spring全家桶）</li><li>学习关系型数据库(MySql/MariaDB/Postgresql)相关知识</li><li>学习缓存（Redis/Memcache）相关知识</li><li>学习消息队列（kafka/RabbitMQ）相关知识</li><li>Linux/网络/TCP IP协议…</li></ol><h2 id="Web后端框架知识点"><a href="#Web后端框架知识点" class="headerlink" title="Web后端框架知识点"></a>Web后端框架知识点</h2><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>后端与前端交互的来源，Request需要掌握的知识点有</p><ul><li>如何获取前端请求过来的参数，GET、POST请求参数如何获取</li><li>如何获取JSON格式的请求体</li><li>如何获取请求上传过来的文件，并保存这些文件</li><li>如何获取动态路由的参数</li><li>如何校验请求过来的参数是否符合要求</li></ul><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>得益于http协议的定义，有请求就必须有响应，Response需要掌握的知识点有</p><ul><li>如何响应文本类型数据</li><li>如何响应JSON类型数据</li><li>如何响应不同的状态码</li><li>如何流式响应（常用于文件下载）</li><li>如何响应模板文件</li></ul><h3 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h3><p>如何让Web框架知道一个Request用哪一个Response来响应，这就需要Routing，Routing主要解决Request和Response的对应关系，这里需要掌握的知识点有：</p><ul><li>路由参数是否支持正则匹配</li><li>动态路由如何配置，有几种配置方法</li><li>是否支持分组路由</li><li>路由规则对应的Response是函数还是类，或者两者都支持</li></ul><h3 id="Cookie-amp-amp-Session"><a href="#Cookie-amp-amp-Session" class="headerlink" title="Cookie &amp;&amp; Session"></a>Cookie &amp;&amp; Session</h3><p>会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份，这里需要掌握的知识点有</p><ul><li>如何获取Cookie</li><li>如何设置Session</li><li>如何从Session中获取值</li></ul><h3 id="MiddleWare"><a href="#MiddleWare" class="headerlink" title="MiddleWare"></a>MiddleWare</h3><p>中间件可以对请求进行拦截，实现各种插件，例如Cors/鉴权，这里需要掌握的知识点有</p><ul><li>如何编写中间件</li><li>中间件可以用在哪些地方，全局 or 路由</li></ul><h3 id="Signal-不全有"><a href="#Signal-不全有" class="headerlink" title="Signal(不全有)"></a>Signal(不全有)</h3><p>信号是一个观察者模式，它允许你配置一个事件，当观察到这个事件发生时，框架会将这个事件发送到某个或多个接收者，接收者接收到这些事件后即可自定义操作。这里需要掌握的知识点有：</p><ul><li>如何定义一个信号观察的事件</li><li>如何接收一个信号</li></ul><h3 id="ORM-微框架一般没有"><a href="#ORM-微框架一般没有" class="headerlink" title="ORM(微框架一般没有)"></a>ORM(微框架一般没有)</h3><p>对象关系映射（Object Relational Mapping，简称ORM），指的是面向对象的对象模型和关系型数据库的数据结构之间的相互转换，简单点理解就是通过代码层对数据库语句的封装，使用简单的代码调用即可调用底层SQL语句，而使用者不需要过多关注底层SQL语句怎么写，ORM需要掌握的知识点如下</p><ul><li>如何配置ORM</li><li>ORM的增删改查如何编写</li><li>ORM是否支持链式操作</li><li>ORM结果如何处理</li><li>ORM事务如何处理</li><li>ORM是否支持主从模式</li><li>ORM是否支持RAW模式</li><li>ORM是否支持查询缓存</li></ul><h3 id="Websocket-有些会自带，有些需要自己集成"><a href="#Websocket-有些会自带，有些需要自己集成" class="headerlink" title="Websocket(有些会自带，有些需要自己集成)"></a>Websocket(有些会自带，有些需要自己集成)</h3><p>长连接的支持是相对短连接而言的，长连接有不少优势，这里需要掌握的知识点有</p><ul><li>如何创建一个长连接服务端</li><li>外部如何操作这个服务端的长连接</li></ul><h3 id="Static-amp-amp-template"><a href="#Static-amp-amp-template" class="headerlink" title="Static &amp;&amp; template"></a>Static &amp;&amp; template</h3><p>静态文件的支持一般是web框架必备的需求，模板的渲染却不是每个Web框架必有的，现流行的请后端分离的web开发模式下，静态文件支持和模板渲染已经越来越边缘化，这里需要掌握的知识点有</p><ul><li>如何配置静态文件支持</li><li>如何渲染模板</li><li>模板语言的语法</li></ul><h3 id="Logging-有些会自带，有些需要自己集成"><a href="#Logging-有些会自带，有些需要自己集成" class="headerlink" title="Logging(有些会自带，有些需要自己集成)"></a>Logging(有些会自带，有些需要自己集成)</h3><p>日志打印的支持并不是web框架都有的，大部分框架都会集成，web开发打印日志是必须的，这方便我们查询问题，定位故障，这里需要掌握的知识点有</p><ul><li>日志如何配置</li><li>是否支持自定义日志文件</li><li>是否支持日志切割</li><li>是否支持日志级别输出</li></ul><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。</p><p>因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现”API First”的设计思想。<code>RESTful API</code>是目前比较成熟的一套互联网应用程序的API设计理论</p><p><code>REST</code>，即Representational State Transfer的缩写。翻译过来是”表现层状态转化”。</p><p>如果一个架构符合REST原则，就称它为RESTful架构。</p><h3 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h3><ul><li><p>每一个URI代表一种资源, 所以资源必须是名词；</p></li><li><p>客户端和服务器之间，传递这种资源的某种表现层；</p></li><li><p>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p></li></ul><h3 id="常见URI设计"><a href="#常见URI设计" class="headerlink" title="常见URI设计"></a>常见URI设计</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /zoos：列出所有动物园</span><br><span class="line">POST /zoos：新建一个动物园</span><br><span class="line">GET <span class="regexp">/zoos/I</span>D：获取某个指定动物园的信息</span><br><span class="line">PUT <span class="regexp">/zoos/I</span>D：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH <span class="regexp">/zoos/I</span>D：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line"><span class="keyword">DELETE</span> <span class="regexp">/zoos/I</span>D：删除某个动物园</span><br><span class="line">GET <span class="regexp">/zoos/I</span>D/animals：列出某个指定动物园的所有动物</span><br><span class="line"><span class="keyword">DELETE</span> <span class="regexp">/zoos/I</span>D<span class="regexp">/animals/I</span>D：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://www.ruanyifeng.com/blog/2011/09/restful.html" title="理解RESTful架构">理解RESTful架构</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" title="RESTful API 设计指南">RESTful API 设计指南</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟 saltstack/ansible系列四（基于长连接实现salt主要功能）</title>
      <link href="/post/1c8b7bb6/"/>
      <url>/post/1c8b7bb6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面讲了基于短连接的saltstack主要功能实现，今天我来讲讲基于长连接方式的saltstack实现。</p><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><h3 id="长连接和短连接的区别"><a href="#长连接和短连接的区别" class="headerlink" title="长连接和短连接的区别"></a>长连接和短连接的区别</h3><p><a href="https://www.cnblogs.com/gotodsp/p/6366163.html">HTTP长连接、短连接究竟是什么？</a></p><h3 id="使用的长连接实现模块"><a href="#使用的长连接实现模块" class="headerlink" title="使用的长连接实现模块"></a>使用的长连接实现模块</h3><p><a href="https://websocket-client.readthedocs.io/en/latest/examples.html">websocket-client</a><br><a href="https://gitlab.com/noppo/gevent-websocket">gevent-websocket</a></p><p>这里没有使用<a href="https://websockets.readthedocs.io/en/stable/">websockets</a>这个库来做长连接的客户端和服务端，主要考虑的是上面2个库来做客户端和服务端的代码更容易理解</p><p>由于以上2个模块都属于第三方库，所以需要使用如下命令先行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install websocket-client gevent-websocket</span><br></pre></td></tr></table></figure><h2 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h2><h3 id="长连接服务端"><a href="#长连接服务端" class="headerlink" title="长连接服务端"></a>长连接服务端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> geventwebsocket <span class="keyword">import</span> WebSocketServer, WebSocketApplication, Resource</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoApplication</span>(<span class="params">WebSocketApplication</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_open</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Connection opened&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">self, message</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">        self.ws.send(<span class="string">&#x27;recieve message&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_close</span>(<span class="params">self, reason</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(reason)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    WebSocketServer(</span><br><span class="line">        (<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">8761</span>),</span><br><span class="line">        Resource(OrderedDict([(<span class="string">&#x27;/ws&#x27;</span>, EchoApplication)]))</span><br><span class="line">    ).serve_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码很容易理解，当程序启动时监听8761端口，当有客户端连入时，on_open方法将会被执行，收到消息时，on_message将会被执行，当长连接关闭时，on_close方法将会被执行。</p><h3 id="长连接客户端"><a href="#长连接客户端" class="headerlink" title="长连接客户端"></a>长连接客户端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">ws, message</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_error</span>(<span class="params">ws, error</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(ws)</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_open</span>(<span class="params">ws</span>):</span></span><br><span class="line">    ws.send(<span class="string">&quot;agent connect to master&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_close</span>(<span class="params">ws, close_status_code, close_msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;### closed ###&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(close_status_code, close_msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keep_alive</span>():</span></span><br><span class="line">    websocket.enableTrace(<span class="literal">False</span>)</span><br><span class="line">    ws = websocket.WebSocketApp(</span><br><span class="line">        <span class="string">&quot;ws://127.0.0.1:8761/ws&quot;</span>,</span><br><span class="line">        on_message=on_message,</span><br><span class="line">        on_open=on_open,</span><br><span class="line">        on_error=on_error,</span><br><span class="line">        on_close=on_close,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    ws.run_forever(suppress_origin=<span class="literal">True</span>, skip_utf8_validation=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    keep_alive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到长连接客户端和服务端代码非常相似，这也是选择这2个模块开发的原因。</p><p>客户端启动时连接服务端的接口，需要特别注意的是websocket的地址是以ws开头（SSL的长连接以wss开头）</p><p>此时，我们运行长连接服务端和客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@demo:/data<span class="comment"># python3 master_socket.py</span></span><br><span class="line">Connection opened</span><br><span class="line">agent connect to master</span><br><span class="line"></span><br><span class="line">root@demo:/data<span class="comment"># python3 agent_socket.py</span></span><br><span class="line">recieve message</span><br></pre></td></tr></table></figure><p>如上，这就代表客户端和服务端长连接已经建立起来。</p><p>此时，我们需要考虑一个问题，假如我们把长连接服务端作为salt-master,客户端作为salt-minion,我们需要怎样做，才能通过salt-master发送指令给salt-minion去执行并且返回执行结果了？</p><p>我们可以看到不管是长连接服务端还是客户端都没有提供类似短连接的接口，也就不存在外部直接发个请求就可以返回数据回来</p><p>我们再看服务端，ws.send()方法即是发送消息给客户端，理论上来说只要我们能控制这个ws对象，就可以发送消息给客户端，那如何控制了？比如说初始化一个ws全局变量，然后on_open时，将on_open(ws)中的ws参数赋值给ws全局变量，然后我们外部只要操作这个ws就可以了？</p><p>但这个方法其实是行不通的，我们的salt-master是控制批量主机的，如此多的salt-minion通过长连接和master通信，ws这个全局变量到底属于哪个远程主机长连接的了？</p><h3 id="基于MQ实现长连接master和agent交互的纽带"><a href="#基于MQ实现长连接master和agent交互的纽带" class="headerlink" title="基于MQ实现长连接master和agent交互的纽带"></a>基于MQ实现长连接master和agent交互的纽带</h3><p>其实，我们可以新增一个消息提供者，用于外部操作salt-master</p><p>我们来看下代码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> geventwebsocket <span class="keyword">import</span> WebSocketServer, WebSocketApplication, Resource</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoApplication</span>(<span class="params">WebSocketApplication</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subscribe_msg</span>(<span class="params">self</span>):</span></span><br><span class="line">        redis_conn = redis.Redis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>, decode_responses=<span class="literal">True</span>) </span><br><span class="line">        ps = redis_conn.pubsub()</span><br><span class="line">        ps.subscribe(<span class="string">&#x27;ws&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> ps.listen():<span class="comment">#监听状态：有消息发布了就拿过来</span></span><br><span class="line">            <span class="keyword">if</span> item[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;message&#x27;</span>:</span><br><span class="line">                msg = item[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">                <span class="built_in">print</span>(msg)</span><br><span class="line">                self.ws.send(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_open</span>(<span class="params">self</span>):</span></span><br><span class="line">        Thread(target=self.subscribe_msg).start()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Connection opened&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">self, message</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">        self.ws.send(<span class="string">&#x27;recieve message&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_close</span>(<span class="params">self, reason</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(reason)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    WebSocketServer(</span><br><span class="line">        (<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">8761</span>),</span><br><span class="line">        Resource(OrderedDict([(<span class="string">&#x27;/ws&#x27;</span>, EchoApplication)]))</span><br><span class="line">    ).serve_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>这里我们使用<code>Redis</code>作为MQ，主要是安装简单、Python操作也简单，也可以使用其他MQ（<code>RabbitMQ</code>、<code>Kafka</code>）,或者使用saltstack使用的<code>zeromq</code>（这里没有看过saltstack的源代码实现，估摸着saltstack也是通过<code>zeromq</code>来让外部操作salt-master的）</p><p>以上代码很简单，我们在长连接服务端新加了个方法，用于操作外部Redis，监听外部Redis的发布订阅模块，如果ws这个key有消息生成，这边就会消费它，即通过ws.send()方法发送给客户端；然后我们在on_open方法中起一个线程去处理这个操作外部Redis的操作。此时，我们只要在外部操作这个Redis的pubsub中的ws key,新增消息，例如<code>&#123;&#39;ip&#39;: xxx, &#39;cmd&#39;: &#39;df -h&#39;&#125;</code>,我们就可以根据IP发送给具体的salt-minion去执行具体的命令</p><h3 id="长连接客户端如何执行服务端发过来的消息"><a href="#长连接客户端如何执行服务端发过来的消息" class="headerlink" title="长连接客户端如何执行服务端发过来的消息"></a>长连接客户端如何执行服务端发过来的消息</h3><p>其实我们前面讲了短连接的实现，就是为了长连接做铺垫，比如说执行命令，我们只要将短连接的执行命令代码稍作修改搬过来用即可</p><p>代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> websocket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_cmd</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    <span class="comment"># 基于subprocess.Popen方法执行本地shell命令</span></span><br><span class="line">    proc = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">if</span> proc:</span><br><span class="line">        result = proc.stdout.read()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">ws, message</span>):</span></span><br><span class="line">    <span class="comment"># 获取服务端发送过来的命令，然后执行返回给服务端</span></span><br><span class="line">    result = exec_cmd(message.get(<span class="string">&#x27;cmd&#x27;</span>))</span><br><span class="line">    ws.send(result)</span><br><span class="line">    <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_error</span>(<span class="params">ws, error</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(ws)</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_open</span>(<span class="params">ws</span>):</span></span><br><span class="line">    ws.send(<span class="string">&quot;agent connect to master&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_close</span>(<span class="params">ws, close_status_code, close_msg</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;### closed ###&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(close_status_code, close_msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keep_alive</span>():</span></span><br><span class="line">    websocket.enableTrace(<span class="literal">False</span>)</span><br><span class="line">    ws = websocket.WebSocketApp(</span><br><span class="line">        <span class="string">&quot;ws://127.0.0.1:8761/ws&quot;</span>,</span><br><span class="line">        on_message=on_message,</span><br><span class="line">        on_open=on_open,</span><br><span class="line">        on_error=on_error,</span><br><span class="line">        on_close=on_close,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    ws.run_forever(suppress_origin=<span class="literal">True</span>, skip_utf8_validation=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    keep_alive()</span><br></pre></td></tr></table></figure></p><p>这里只是将执行命令的方法搬过来，上传下载文件原理类似，这里不再赘述</p><blockquote><p>最后</p></blockquote><p>近几篇文章我们通过SSH实现了ansible主要功能、通过短连接和长连接实现saltstack主要功能，下一篇文章我们来讲讲如何模拟saltstack和ansible的命令行来操作远程主机</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> devops </tag>
            
            <tag> linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟 saltstack/ansible 系列三（基于短连接实现saltstack主要功能）</title>
      <link href="/post/3de380ec/"/>
      <url>/post/3de380ec/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面讲了基于SSH的ansible实现，今天我来讲讲基于短连接方式的saltstack实现。</p><blockquote><p>为什么要讲基于短连接的saltstack实现呢？</p></blockquote><p>前面不是说saltstack是基于长连接的吗？原因就在于当你掌握了短连接的实现后，长连接就水到渠成了，你也更能理解到短连接和长连接实现的一个区别</p><h2 id="Agent设计"><a href="#Agent设计" class="headerlink" title="Agent设计"></a>Agent设计</h2><p>不管是短连接实现还是长连接实现，都需要在远程主机起一个服务来承担Agent角色，就如同saltstack的<mark class="hl-label blue">salt-minion</mark> 一样。</p><p>下面我们就基于<code>flask</code>来简单实现一个短连接形式的agent（考虑性能的话可以使用<code>sanic</code>,这里用<code>flask</code>的原因是本人团队内部培训时，我主要培训的是<code>flask</code>）</p><p>由于<code>flask</code>属于第三方库，所以需要使用如下命令先行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask</span><br></pre></td></tr></table></figure><p>如果想做成和salt-minion二进制模式启动的话，我们还需要安装一个额外的模块<code>pyinstaller</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure><p>以下是flask作为一个服务端基本的代码: app.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>当我们执行这个代码时，程序将会监听<code>8080</code>端口，请求<code>http://127.0.0.1:8080</code>将会返回Hello, World!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ python3 app.py</span><br><span class="line"></span><br><span class="line"> * Serving Flask app <span class="string">&#x27;app&#x27;</span> (lazy loading)</span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: This is a development server. Do not use it <span class="keyword">in</span> a production deployment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: on</span><br><span class="line"> * Running on all addresses.</span><br><span class="line">   WARNING: This is a development server. Do not use it <span class="keyword">in</span> a production deployment.</span><br><span class="line"> * Running on http://127.0.0.1:8080/ (Press CTRL+C to quit)</span><br><span class="line"> * Restarting with <span class="built_in">stat</span></span><br><span class="line"> * Debugger is active!</span><br><span class="line"> * Debugger PIN: 142-934-530</span><br><span class="line"></span><br><span class="line">$ http http://127.0.0.1:8080</span><br><span class="line"></span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Length: 13</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Date: Wed, 24 Nov 2021 14:46:12 GMT</span><br><span class="line">Server: Werkzeug/2.0.2 Python/3.10.0</span><br><span class="line"></span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p>此时，我们可以通过<code>pyinstaller</code>将该程序编译成一个二进制程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller -F app.py</span><br></pre></td></tr></table></figure><h2 id="saltstack功能分析与代码实现"><a href="#saltstack功能分析与代码实现" class="headerlink" title="saltstack功能分析与代码实现"></a>saltstack功能分析与代码实现</h2><h3 id="连接远程主机"><a href="#连接远程主机" class="headerlink" title="连接远程主机"></a>连接远程主机</h3><p>基于短连接实现的agent，连接远程主机功能只需要判断接口是否能通即可，如上我们请求<code>http://127.0.0.1:8080</code>时返回200状态码，即可认为成功连接远程主机。</p><h3 id="test-ping"><a href="#test-ping" class="headerlink" title="test.ping"></a>test.ping</h3><p>ping功能的实现，我们可以写个ping接口，然后返回pong来实现，或者根据返回状态码是否为200来判断</p><p>我们把上边的app.py修改一下，加上ping接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/ping&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pong&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>此时我们请求<code>http://127.0.0.1:8080/ping</code>则会返回pong,此时即可认为远程主机在线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ http http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>/ping</span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-Length: <span class="number">4</span></span><br><span class="line">Content-<span class="type">Type</span>: text/html; charset=utf-<span class="number">8</span></span><br><span class="line">Date: Wed, <span class="number">24</span> Nov <span class="number">2021</span> <span class="number">15</span>:04:<span class="number">58</span> GMT</span><br><span class="line">Server: Werkzeug/<span class="number">2.0</span><span class="number">.2</span> Python/<span class="number">3.10</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">pong</span><br></pre></td></tr></table></figure><h3 id="cmd-run"><a href="#cmd-run" class="headerlink" title="cmd.run"></a>cmd.run</h3><p>执行命令我们可以再写一个接收POST请求的接口，接收一个参数，用于命令的传入，然后根据传入的命令在本地主机执行命令，获取命令返回的结果后响应给客户端。</p><p>我们把上边的app.py增加一个cmd接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/ping&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pong&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmd&quot;</span>, methods=[<span class="string">&quot;post&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>():</span></span><br><span class="line">    body = request.json</span><br><span class="line">    cmd = body.get(<span class="string">&quot;cmd&quot;</span>)</span><br><span class="line">    <span class="comment"># 基于subprocess.Popen方法执行本地shell命令</span></span><br><span class="line">    proc = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">if</span> proc:</span><br><span class="line">        result = proc.stdout.read()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>此时我们请求<code>http://127.0.0.1:8080/cmd</code>,传入命令，则会返回命令结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ http http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>/cmd cmd=<span class="string">&#x27;df -h&#x27;</span></span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-Length: <span class="number">590</span></span><br><span class="line">Content-<span class="type">Type</span>: text/html; charset=utf-<span class="number">8</span></span><br><span class="line">Date: Wed, <span class="number">24</span> Nov <span class="number">2021</span> <span class="number">15</span>:<span class="number">25</span>:<span class="number">24</span> GMT</span><br><span class="line">Server: Werkzeug/<span class="number">2.0</span><span class="number">.2</span> Python/<span class="number">3.8</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            957M     <span class="number">0</span>  957M   <span class="number">0</span>% /dev</span><br><span class="line">tmpfs           198M  <span class="number">1.1</span>M  197M   <span class="number">1</span>% /run</span><br><span class="line">/dev/sda1        20G  <span class="number">1.5</span>G   18G   <span class="number">8</span>% /</span><br><span class="line">tmpfs           990M     <span class="number">0</span>  990M   <span class="number">0</span>% /dev/shm</span><br><span class="line">tmpfs           <span class="number">5.0</span>M     <span class="number">0</span>  <span class="number">5.0</span>M   <span class="number">0</span>% /run/lock</span><br><span class="line">tmpfs           990M     <span class="number">0</span>  990M   <span class="number">0</span>% /sys/fs/cgroup</span><br><span class="line">/dev/sda15       98M  290K   98M   <span class="number">1</span>% /boot/efi</span><br><span class="line">/dev/loop0       61M   61M     <span class="number">0</span> <span class="number">100</span>% /snap/lxd/<span class="number">21843</span></span><br><span class="line">/dev/loop2       29M   29M     <span class="number">0</span> <span class="number">100</span>% /snap/snapd/<span class="number">13643</span></span><br><span class="line">/dev/loop1       58M   58M     <span class="number">0</span> <span class="number">100</span>% /snap/core20/<span class="number">1244</span></span><br><span class="line">tmpfs           198M     <span class="number">0</span>  198M   <span class="number">0</span>% /run/user/<span class="number">1000</span></span><br></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>执行命令我们可以再写一个接收文件的接口，将客户端上传过来的文件保存到本地，可以接收一个目标目录的参数，用做存放文件的目录</p><p>我们把上边的app.py增加一个upload_file接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/ping&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pong&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmd&quot;</span>, methods=[<span class="string">&quot;post&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>():</span></span><br><span class="line">    body = request.json</span><br><span class="line">    cmd = body.get(<span class="string">&quot;cmd&quot;</span>)</span><br><span class="line">    <span class="comment"># 基于subprocess.Popen方法执行本地shell命令</span></span><br><span class="line">    proc = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">if</span> proc:</span><br><span class="line">        result = proc.stdout.read()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/upload_file&quot;</span>, methods=[<span class="string">&quot;post&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span>():</span></span><br><span class="line">    <span class="comment"># 从请求中获取文件，如果上传的不是以file为key的文件，则认为未上传文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;file&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> request.files:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;not find file in request.files&quot;</span></span><br><span class="line">    file = request.files[<span class="string">&quot;file&quot;</span>]</span><br><span class="line">    <span class="comment"># 如果请求没有带dest参数，则dest默认为/opt</span></span><br><span class="line">    dest = request.args.get(<span class="string">&quot;dest&quot;</span>, <span class="string">&quot;/opt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> file:</span><br><span class="line">        file.save(dest)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;file uploaded successfully&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;upload error&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span>(<span class="params">src, dest</span>):</span></span><br><span class="line">    resp = requests.post(</span><br><span class="line">        <span class="string">&quot;http://127.0.0.1:8080/upload_file?dest=&quot;</span> + dest,</span><br><span class="line">        files=&#123;<span class="string">&quot;file&quot;</span>: <span class="built_in">open</span>(src, <span class="string">&quot;rb&quot;</span>)&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> resp.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> resp.text</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>此时客户端请求<code>http://127.0.0.1:8080/upload_file</code>,传入参数，则上传文件成功</p><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>下载文件我们可以写个接口，接收文件所在目录地址和文件名2个参数</p><p>我们把上边的app.py增加一个download_file接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/ping&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;pong&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/cmd&quot;</span>, methods=[<span class="string">&quot;post&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>():</span></span><br><span class="line">    body = request.json</span><br><span class="line">    cmd = body.get(<span class="string">&quot;cmd&quot;</span>)</span><br><span class="line">    <span class="comment"># 基于subprocess.Popen方法执行本地shell命令</span></span><br><span class="line">    proc = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">if</span> proc:</span><br><span class="line">        result = proc.stdout.read()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/upload_file&quot;</span>, methods=[<span class="string">&quot;post&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span>():</span></span><br><span class="line">    <span class="comment"># 从请求中获取文件，如果上传的不是以file为key的文件，则认为未上传文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;file&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> request.files:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;not find file in request.files&quot;</span></span><br><span class="line">    file = request.files[<span class="string">&quot;file&quot;</span>]</span><br><span class="line">    <span class="comment"># 如果请求没有带dest参数，则dest默认为/opt</span></span><br><span class="line">    dest = request.args.get(<span class="string">&quot;dest&quot;</span>, <span class="string">&quot;/opt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> file:</span><br><span class="line">        file.save(dest)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;file uploaded successfully&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;upload error&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/download_file&quot;</span>, methods=[<span class="string">&quot;post&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_file</span>():</span></span><br><span class="line">    body = request.json</span><br><span class="line">    directory = body.get(<span class="string">&quot;directory&quot;</span>)</span><br><span class="line">    filename = body.get(<span class="string">&quot;filename&quot;</span>)</span><br><span class="line">    <span class="comment"># send_from_directory用于发送本地的文件</span></span><br><span class="line">    <span class="keyword">return</span> send_from_directory(</span><br><span class="line">        directory=directory, filename=filename, as_attachment=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_file</span>(<span class="params">src, dest</span>):</span></span><br><span class="line">    filename = src.split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">    directory = src.replace(filename, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(directory, filename)</span><br><span class="line">    data = &#123;<span class="string">&quot;directory&quot;</span>: directory, <span class="string">&quot;filename&quot;</span>: filename&#125;</span><br><span class="line">    resp = requests.post(<span class="string">&quot;http://127.0.0.1:8080/download_file&quot;</span>, json=data)</span><br><span class="line">    <span class="keyword">if</span> resp.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(dest, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(resp.content)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>以上接口基本上实现saltstack常用功能。下一文章我们来讲讲长连接实现saltstack基本功能</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> devops </tag>
            
            <tag> linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟 saltstack/ansible 系列二（实现ansible主要功能）</title>
      <link href="/post/b95044a6/"/>
      <url>/post/b95044a6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次主要分享是如何基于Python模拟实现ansible的主要功能</p><h2 id="ansible功能分析与代码实现"><a href="#ansible功能分析与代码实现" class="headerlink" title="ansible功能分析与代码实现"></a>ansible功能分析与代码实现</h2><h3 id="连接远程主机"><a href="#连接远程主机" class="headerlink" title="连接远程主机"></a>连接远程主机</h3><p>ansible连接远程主机是通过SSH实现的，因此我们可以通过Python的SSH模块来实现连接远程主机。</p><p>Python中SSH模块主要是三方的<mark class="hl-label pink">paramiko</mark> 模块，这个模块也是ansible内部实现SSH所用的模块。</p><p>由于paramiko属于第三方库，所以需要使用如下命令先行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install paramiko</span><br></pre></td></tr></table></figure><p>下面是使用paramiko进行SSH连接和SFTP连接的相关代码</p><blockquote><p>获取一个SSH连接</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ssh_conn</span>(<span class="params">hostname, port, username, password</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 实例化SSHClient</span></span><br><span class="line">        ssh_client = paramiko.SSHClient()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当远程服务器没有本地主机的密钥时自动添加到本地，这样不用在建立连接的时候输入yes或no进行确认</span></span><br><span class="line">        ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        <span class="comment"># 连接SSH服务器，这里以账号密码的方式进行认证，也可以用key认证</span></span><br><span class="line">        ssh_client.connect(</span><br><span class="line">            hostname=hostname, port=port, username=username, password=password, timeout=<span class="number">5</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> ssh_client</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.info(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><blockquote><p>获取一个SFTP连接</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sftp_conn</span>(<span class="params">hostname, port, username, password</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># paramiko sftp功能需要先初始化一个Transport，有点类似打开一个文件传输通道</span></span><br><span class="line">        t = paramiko.Transport((hostname, port))</span><br><span class="line">        t.banner_timeout = <span class="number">10</span></span><br><span class="line">        t.connect(username=username, password=password)</span><br><span class="line">        sftp = paramiko.SFTPClient.from_transport(t)</span><br><span class="line">        <span class="keyword">return</span> sftp</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>paramiko既然能连接主机，当然也能执行命令</p><blockquote><p>基于SSH连接执行命令</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_ssh_command</span>(<span class="params">ssh_client, cmd</span>):</span></span><br><span class="line">    <span class="comment"># 这个类似Popen执行命令，返回三个byte类型值，需要解码</span></span><br><span class="line">    stdin, stdout, stderr = ssh_client.exec_command(cmd, timeout=<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">return</span> stderr.read().decode(), stdout.read().decode()</span><br></pre></td></tr></table></figure><h3 id="上传下载文件"><a href="#上传下载文件" class="headerlink" title="上传下载文件"></a>上传下载文件</h3><p>当我们初始化好后SFTP连接后，就可以对远程服务器进行文件上传下载了</p><blockquote><p>基于SFTP连接进行文件上传下载</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># put上传文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span>(<span class="params">sftp, src, dest</span>):</span></span><br><span class="line">    sftp.put(src, dest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get下载文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_file</span>(<span class="params">sftp, src, dest</span>):</span></span><br><span class="line">    sftp.get(src, dest)</span><br></pre></td></tr></table></figure><h3 id="ansible的ping功能"><a href="#ansible的ping功能" class="headerlink" title="ansible的ping功能"></a>ansible的ping功能</h3><p>其实我们可以通过paramiko是否能ssh连接远程主机作为ping功能实现的原理，当ssh能连接成功时，会返回一个sshclient，否则返回None，参考<code>获取一个SSH连接</code>的代码</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> devops </tag>
            
            <tag> linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟saltstack/ansible系列一（序言）</title>
      <link href="/post/e4dbd1fc/"/>
      <url>/post/e4dbd1fc/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><ul><li>做过运维的同学应该都知道，<mark class="hl-label blue">saltstack</mark> 和<mark class="hl-label green">ansible</mark> 都是运维常用的自动化工具，可以用来做批量系统配置、批量程序部署、批量运行命令等功能</li><li>本教程将分析saltstack和ansible的核心功能实现，然后自己用<mark class="hl-label pink">Python</mark> 实现一个类似saltstack和ansible的项目</li></ul><h3 id="saltstack、ansible原理"><a href="#saltstack、ansible原理" class="headerlink" title="saltstack、ansible原理"></a>saltstack、ansible原理</h3><blockquote><p>ansible</p></blockquote><ul><li>无Agent架构，基于SSH</li><li>ansible playbook可以按任务对批量主机编排</li><li>Python语言开发</li></ul><blockquote><p>saltstack</p></blockquote><ul><li>Agent架构，基于长连接</li><li>可以通过state文件来对批量主机编排</li><li>Python语言开发</li></ul><h2 id="自己如何开发一个实现ansible和saltstack基本功能的程序？"><a href="#自己如何开发一个实现ansible和saltstack基本功能的程序？" class="headerlink" title="自己如何开发一个实现ansible和saltstack基本功能的程序？"></a>自己如何开发一个实现ansible和saltstack基本功能的程序？</h2><h3 id="具体实现功能"><a href="#具体实现功能" class="headerlink" title="具体实现功能"></a>具体实现功能</h3><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>主机连接模式</p>            </div><ul><li>SSH连接模式</li><li>短连接模式</li><li>websocket长连接模式</li></ul><div class='checkbox red checked'><input type="checkbox" checked="checked"/>            <p>Ad-hoc</p>            </div><ul><li>ping功能</li><li>执行命令功能</li><li>copy文件功能</li><li>fetch文件功能</li></ul><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>模拟playbook、state文件执行</p>            </div><ul><li>YAML读取</li><li>模板文件读取与配置</li><li>根据配置执行方法</li></ul><div class='checkbox pink checked'><input type="checkbox" checked="checked"/>            <p>模拟ansible和saltstack命令行参数功能</p>            </div><h3 id="开发语言"><a href="#开发语言" class="headerlink" title="开发语言"></a>开发语言</h3><p>Python（也可以用Go，主要是本人部门主用Python）</p><h3 id="使用的Python模块"><a href="#使用的Python模块" class="headerlink" title="使用的Python模块"></a>使用的Python模块</h3><ul><li>paramiko: SSH连接、SFTP上传下载文件、执行命令</li><li>ruamel/PyYaml: 解析YAML配置文件</li><li>jinja2: 模板引擎</li><li>click： 命令行模块</li><li>flask/sanic: web框架，agent使用</li><li>geventwebsocket： websocket服务端</li><li>websocket： websocket客户端</li><li>redis: 作为MQ，也可以用其他MQ</li><li>colorama：终端输入颜色字体</li><li>requests/httpx: http请求框架</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> devops </tag>
            
            <tag> linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客撰写计划</title>
      <link href="/post/50c5b9ad/"/>
      <url>/post/50c5b9ad/</url>
      
        <content type="html"><![CDATA[<div class="note danger modern"><p>缘起</p></div><p>这些年记忆力越来越差，趁我还没老，趁我还在从事运维开发的工作，在这里记录下运维以及运维开发过程中经验，分享下运维以及运维开发的技术实战，分享尽量以项目实战为主！</p><div class="note primary flat"><p>运维管理平台项目</p></div><div class='checkbox'><input type="checkbox" />            <p>CMDB</p>            </div><div class='checkbox'><input type="checkbox" />            <p>WEBSSH</p>            </div><div class='checkbox'><input type="checkbox" />            <p>任务管理</p>            </div><div class='checkbox'><input type="checkbox" />            <p>发布部署</p>            </div><div class='checkbox'><input type="checkbox" />            <p>操作日志</p>            </div><div class='checkbox'><input type="checkbox" />            <p>权限管理</p>            </div><div class='checkbox'><input type="checkbox" />            <p>用户管理</p>            </div><div class="note info flat"><p>模拟K8s管理系统</p></div><div class='checkbox'><input type="checkbox" />            <p>docker管理</p>            </div><div class='checkbox'><input type="checkbox" />            <p>容器调度</p>            </div><div class='checkbox'><input type="checkbox" />            <p>容器编排</p>            </div><div class="note success flat"><p>模拟salt/Ansible</p></div><div class='checkbox'><input type="checkbox" />            <p>SSH形式、短连接模式、websocket长连接模式</p>            </div><div class='checkbox'><input type="checkbox" />            <p>Ad-hoc</p>            </div><div class='checkbox'><input type="checkbox" />            <p>playbook</p>            </div><div class="note warning flat"><p>分布式监控系统</p></div><div class='checkbox'><input type="checkbox" />            <p>模仿zabbix、open-falcon、promethus等</p>            </div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> go </tag>
            
            <tag> devops </tag>
            
            <tag> linux </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M1 MAC安装ubuntu系统的另一个选择-Multipass</title>
      <link href="/post/510972a/"/>
      <url>/post/510972a/</url>
      
        <content type="html"><![CDATA[<div class="note primary modern"><p>缘起</p></div><p>今年Apple发布了新款搭载M1 Pro和M1 Max芯片的Macbook Pro，看着那屏幕甚是喜欢，性能也是爆炸。由于自己用了快2年的豆子峡谷黑苹果，貌似是CPU硅脂没了，温度动不动100℃，导致系统自动死机或重启，于是果断换成了丐版标配的M1 Pro Macbook。别说，新版Mac真的香!</p><p>由于M1芯片基于ARM，所以一些软件或虚拟机都得搞成ARM的，试过Parallels Desktop,搞起来不是很方便，巧合的突然想起以前下载Ubuntu server镜像时看到Multipass工具，它可以快速的初始化一个Linux系统，于是搜索了下发现Multipass工具已支持ARM运行Linux。so,开干！</p><div class="note info modern"><p>Multipass官网介绍</p></div><p><a href="https://github.com/canonical/multipass">Multipass</a> is a lightweight VM manager for Linux, Windows and macOS. It’s designed for developers who want a fresh Ubuntu environment with a single command. It uses KVM on Linux, Hyper-V on Windows and HyperKit on macOS to run the VM with minimal overhead. It can also use VirtualBox on Windows and macOS. Multipass will fetch images for you and keep them up to date.</p><p>Since it supports metadata for cloud-init, you can simulate a small cloud deployment on your laptop or workstation.</p><p>简单点说，该工具是一个虚拟机管理器，它在 Linux 上使用 KVM，在 Windows 上使用 Hyper-V，在 macOS 上使用 HyperKit 以最小的开销运行 VM，有点类似Docker</p><div class="note success modern"><p>安装</p></div><p><strong>Linux</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install multipass</span><br></pre></td></tr></table></figure></p><p><strong>Mac</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask multipass</span><br></pre></td></tr></table></figure></p><div class="note default modern"><p>使用</p></div><blockquote><p>快速启动一个VM</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ multipass launch --name <span class="built_in">test</span></span><br></pre></td></tr></table></figure><blockquote><p>具体配置内存、CPU、磁盘、系统版本来启动VM</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ multipass launch -n <span class="built_in">test</span>  -c 2 -m 2G -d 20G 20.04</span><br></pre></td></tr></table></figure><blockquote><p>查看multipass具体支持什么系统</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ multipass find</span><br><span class="line">Image                       Aliases           Version          Description</span><br><span class="line">18.04                       bionic            20211122         Ubuntu 18.04 LTS</span><br><span class="line">20.04                       focal,lts         20211118         Ubuntu 20.04 LTS</span><br><span class="line">21.04                       hirsute           20211119         Ubuntu 21.04</span><br><span class="line">21.10                       impish            20211103         Ubuntu 21.10</span><br><span class="line">anbox-cloud-appliance                         latest           Anbox Cloud Appliance</span><br><span class="line">minikube                                      latest           minikube is <span class="built_in">local</span> Kubernetes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以看到multipass还能安装minikube,这样来说快速初始化一个K8s单机实例是如此简单</p><blockquote><p>查看启动的虚拟机列表<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ multipass list</span><br><span class="line">Name                    State             IPv4             Image</span><br><span class="line"><span class="built_in">test</span>                    Running           192.168.64.2     Ubuntu 20.04 LTS</span><br></pre></td></tr></table></figure></p><p>查看某个虚拟机具体信息</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ multipass info <span class="built_in">test</span></span><br><span class="line">Name:           <span class="built_in">test</span></span><br><span class="line">State:          Running</span><br><span class="line">IPv4:           192.168.64.2</span><br><span class="line">Release:        Ubuntu 20.04.3 LTS</span><br><span class="line">Image <span class="built_in">hash</span>:     e9271036efcd (Ubuntu 20.04 LTS)</span><br><span class="line">Load:           0.00 0.00 0.00</span><br><span class="line">Disk usage:     1.2G out of 19.2G</span><br><span class="line">Memory usage:   154.8M out of 1.9G</span><br><span class="line">Mounts:         --</span><br></pre></td></tr></table></figure><blockquote><p>外部执行虚拟机内部命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ multipass <span class="built_in">exec</span> <span class="built_in">test</span> -- df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            957M     0  957M   0% /dev</span><br><span class="line">tmpfs           198M  1.1M  197M   1% /run</span><br><span class="line">/dev/sda1        20G  1.3G   18G   7% /</span><br><span class="line">tmpfs           990M     0  990M   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           990M     0  990M   0% /sys/fs/cgroup</span><br><span class="line">/dev/loop0       58M   58M     0 100% /snap/core20/1244</span><br><span class="line">/dev/sda15       98M  290K   98M   1% /boot/efi</span><br><span class="line">/dev/loop1       61M   61M     0 100% /snap/lxd/21843</span><br><span class="line">/dev/loop2       29M   29M     0 100% /snap/snapd/13643</span><br><span class="line">tmpfs           198M     0  198M   0% /run/user/1000</span><br></pre></td></tr></table></figure><p>看，这语法是不是很像k8s kubectl连接pod语法</p><blockquote><p>连接到正在运行的实例‎</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ multipass shell <span class="built_in">test</span></span><br><span class="line">Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.4.0-90-generic aarch64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Tue Nov 23 15:32:09 CST 2021</span><br><span class="line"></span><br><span class="line">  System load:             0.0</span><br><span class="line">  Usage of /:              6.4% of 19.22GB</span><br><span class="line">  Memory usage:            10%</span><br><span class="line">  Swap usage:              0%</span><br><span class="line">  Processes:               112</span><br><span class="line">  Users logged <span class="keyword">in</span>:         0</span><br><span class="line">  IPv4 address <span class="keyword">for</span> enp0s1: 192.168.64.2</span><br><span class="line">  IPv6 address <span class="keyword">for</span> enp0s1: fd0a:c754:c0d:703c:5054:ff:febd:2caa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0 updates can be applied immediately.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last login: Tue Nov 23 15:29:51 2021 from 192.168.64.1</span><br><span class="line">ubuntu@<span class="built_in">test</span>:~$</span><br></pre></td></tr></table></figure><blockquote><p>停止VM</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ multipass stop <span class="built_in">test</span></span><br></pre></td></tr></table></figure><blockquote><p>启动VM</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ multipass start <span class="built_in">test</span></span><br></pre></td></tr></table></figure><blockquote><p>删除VM(只是进入DELETED状态)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ multipass delete <span class="built_in">test</span></span><br></pre></td></tr></table></figure><blockquote><p>完全删除VM</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ multipass purge</span><br></pre></td></tr></table></figure><blockquote><p>更多语法</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ multipass <span class="built_in">help</span></span><br><span class="line">Usage: multipass [options] &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">Create, control and connect to Ubuntu instances.</span><br><span class="line"></span><br><span class="line">This is a <span class="built_in">command</span> line utility <span class="keyword">for</span> multipass, a</span><br><span class="line">service that manages Ubuntu instances.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --<span class="built_in">help</span>     Displays <span class="built_in">help</span> on commandline options.</span><br><span class="line">  --help-all     Displays <span class="built_in">help</span> including Qt specific options.</span><br><span class="line">  -v, --verbose  Increase logging verbosity. Repeat the <span class="string">&#x27;v&#x27;</span> <span class="keyword">in</span> the short option</span><br><span class="line">                 <span class="keyword">for</span> more detail. Maximum verbosity is obtained with 4 (or more)</span><br><span class="line">                 v<span class="string">&#x27;s, i.e. -vvvv.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Available commands:</span></span><br><span class="line"><span class="string">  alias     Create an alias</span></span><br><span class="line"><span class="string">  aliases   List available aliases</span></span><br><span class="line"><span class="string">  delete    Delete instances</span></span><br><span class="line"><span class="string">  exec      Run a command on an instance</span></span><br><span class="line"><span class="string">  find      Display available images to create instances from</span></span><br><span class="line"><span class="string">  get       Get a configuration setting</span></span><br><span class="line"><span class="string">  help      Display help about a command</span></span><br><span class="line"><span class="string">  info      Display information about instances</span></span><br><span class="line"><span class="string">  launch    Create and start an Ubuntu instance</span></span><br><span class="line"><span class="string">  list      List all available instances</span></span><br><span class="line"><span class="string">  mount     Mount a local directory in the instance</span></span><br><span class="line"><span class="string">  networks  List available network interfaces</span></span><br><span class="line"><span class="string">  purge     Purge all deleted instances permanently</span></span><br><span class="line"><span class="string">  recover   Recover deleted instances</span></span><br><span class="line"><span class="string">  restart   Restart instances</span></span><br><span class="line"><span class="string">  set       Set a configuration setting</span></span><br><span class="line"><span class="string">  shell     Open a shell on a running instance</span></span><br><span class="line"><span class="string">  start     Start instances</span></span><br><span class="line"><span class="string">  stop      Stop running instances</span></span><br><span class="line"><span class="string">  suspend   Suspend running instances</span></span><br><span class="line"><span class="string">  transfer  Transfer files between the host and instances</span></span><br><span class="line"><span class="string">  umount    Unmount a directory from an instance</span></span><br><span class="line"><span class="string">  unalias   Remove an alias</span></span><br><span class="line"><span class="string">  version   Show version details</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ multipass launch -h</span><br><span class="line">Usage: multipass launch [options] [[&lt;remote:&gt;]&lt;image&gt; | &lt;url&gt;]</span><br><span class="line">Create and start a new instance.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --<span class="built_in">help</span>           Displays <span class="built_in">help</span> on commandline options.</span><br><span class="line">  --help-all           Displays <span class="built_in">help</span> including Qt specific options.</span><br><span class="line">  -v, --verbose        Increase logging verbosity. Repeat the <span class="string">&#x27;v&#x27;</span> <span class="keyword">in</span> the short</span><br><span class="line">                       option <span class="keyword">for</span> more detail. Maximum verbosity is obtained</span><br><span class="line">                       with 4 (or more) v<span class="string">&#x27;s, i.e. -vvvv.</span></span><br><span class="line"><span class="string">  -c, --cpus &lt;cpus&gt;    Number of CPUs to allocate.</span></span><br><span class="line"><span class="string">                       Minimum: 1, default: 1.</span></span><br><span class="line"><span class="string">  -d, --disk &lt;disk&gt;    Disk space to allocate. Positive integers, in bytes, or</span></span><br><span class="line"><span class="string">                       with K, M, G suffix.</span></span><br><span class="line"><span class="string">                       Minimum: 512M, default: 5G.</span></span><br><span class="line"><span class="string">  -m, --mem &lt;mem&gt;      Amount of memory to allocate. Positive integers, in</span></span><br><span class="line"><span class="string">                       bytes, or with K, M, G suffix.</span></span><br><span class="line"><span class="string">                       Minimum: 128M, default: 1G.</span></span><br><span class="line"><span class="string">  -n, --name &lt;name&gt;    Name for the instance. If it is &#x27;</span>primary<span class="string">&#x27; (the</span></span><br><span class="line"><span class="string">                       configured primary instance name), the user&#x27;</span>s home</span><br><span class="line">                       directory is mounted inside the newly launched instance,</span><br><span class="line">                       <span class="keyword">in</span> <span class="string">&#x27;Home&#x27;</span>.</span><br><span class="line">  --cloud-init &lt;file&gt;  Path to a user-data cloud-init configuration, or <span class="string">&#x27;-&#x27;</span> <span class="keyword">for</span></span><br><span class="line">                       stdin</span><br><span class="line">  --network &lt;spec&gt;     Add a network interface to the instance, <span class="built_in">where</span> &lt;spec&gt; is</span><br><span class="line">                       <span class="keyword">in</span> the <span class="string">&quot;key=value,key=value&quot;</span> format, with the following</span><br><span class="line">                       keys available:</span><br><span class="line">                        name: the network to connect to (required), use the</span><br><span class="line">                       networks <span class="built_in">command</span> <span class="keyword">for</span> a list of possible values, or use</span><br><span class="line">                       <span class="string">&#x27;bridged&#x27;</span> to use the interface configured via `multipass</span><br><span class="line">                       <span class="built_in">set</span> local.bridged-network`.</span><br><span class="line">                        mode: auto|manual (default: auto)</span><br><span class="line">                        mac: hardware address (default: random).</span><br><span class="line">                       You can also use a shortcut of <span class="string">&quot;&lt;name&gt;&quot;</span> to mean</span><br><span class="line">                       <span class="string">&quot;name=&lt;name&gt;&quot;</span>.</span><br><span class="line">  --bridged            Adds one `--network bridged` network.</span><br><span class="line">  --timeout &lt;timeout&gt;  Maximum time, <span class="keyword">in</span> seconds, to <span class="built_in">wait</span> <span class="keyword">for</span> the <span class="built_in">command</span> to</span><br><span class="line">                       complete. Note that some background operations may</span><br><span class="line">                       <span class="built_in">continue</span> beyond that. By default, instance startup and</span><br><span class="line">                       initialization is limited to 5 minutes each.</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line">  image                Optional image to launch. If omitted, <span class="keyword">then</span> the default</span><br><span class="line">                       Ubuntu LTS will be used.</span><br><span class="line">                       &lt;remote&gt; can be either ‘release’ or ‘daily‘. If &lt;remote&gt;</span><br><span class="line">                       is omitted, ‘release’ will be used.</span><br><span class="line">                       &lt;image&gt; can be a partial image <span class="built_in">hash</span> or an Ubuntu release</span><br><span class="line">                       version, codename or <span class="built_in">alias</span>.</span><br><span class="line">                       &lt;url&gt; is a custom image URL that is <span class="keyword">in</span> http://, https://,</span><br><span class="line">                       or file:// format.</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note warning modern"><p>拓展</p></div><blockquote><p>SSH连接multipass启动的VM</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">multipass shell <span class="built_in">test</span></span><br><span class="line">sudo -i <span class="comment"># 切到root用户</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">将PasswordAuthentication no修改为</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">将PermitRootLogin prohibit-password修改为</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">重启ssh</span><br><span class="line">service ssh restart</span><br><span class="line">现在就可以愉快的ssh登录了</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156/"/>
      <url>/post/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post221&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
